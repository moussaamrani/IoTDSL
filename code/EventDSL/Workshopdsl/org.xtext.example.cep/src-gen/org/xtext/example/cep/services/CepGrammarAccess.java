/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.cep.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class CepGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.Model");
		private final Assignment cRuleAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cRuleRuleParserRuleCall_0 = (RuleCall)cRuleAssignment.eContents().get(0);
		
		//Model:
		//	rule+=Rule*;
		@Override public ParserRule getRule() { return rule; }
		
		//rule+=Rule*
		public Assignment getRuleAssignment() { return cRuleAssignment; }
		
		//Rule
		public RuleCall getRuleRuleParserRuleCall_0() { return cRuleRuleParserRuleCall_0; }
	}
	public class RuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.Rule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cComplexEventParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cFromKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPatternAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPatternExpressionParserRuleCall_3_0 = (RuleCall)cPatternAssignment_3.eContents().get(0);
		private final Keyword cWhereKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cConditionExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cConditionExpressionIDTerminalRuleCall_5_0 = (RuleCall)cConditionExpressionAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// * mode de test * / Rule:
		//	'Define' ComplexEvent
		//	'From' Pattern=Expression
		//	'Where' conditionExpression=ID ';'
		//	// 'consuming'  listOfConsumption  
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'Define' ComplexEvent 'From' Pattern=Expression 'Where' conditionExpression=ID ';'
		public Group getGroup() { return cGroup; }
		
		//'Define'
		public Keyword getDefineKeyword_0() { return cDefineKeyword_0; }
		
		//ComplexEvent
		public RuleCall getComplexEventParserRuleCall_1() { return cComplexEventParserRuleCall_1; }
		
		//'From'
		public Keyword getFromKeyword_2() { return cFromKeyword_2; }
		
		//Pattern=Expression
		public Assignment getPatternAssignment_3() { return cPatternAssignment_3; }
		
		//Expression
		public RuleCall getPatternExpressionParserRuleCall_3_0() { return cPatternExpressionParserRuleCall_3_0; }
		
		//'Where'
		public Keyword getWhereKeyword_4() { return cWhereKeyword_4; }
		
		//conditionExpression=ID
		public Assignment getConditionExpressionAssignment_5() { return cConditionExpressionAssignment_5; }
		
		//ID
		public RuleCall getConditionExpressionIDTerminalRuleCall_5_0() { return cConditionExpressionIDTerminalRuleCall_5_0; }
		
		//';'
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}
	public class ComplexEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.ComplexEvent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParamsCEParameterParserRuleCall_2_0_0 = (RuleCall)cParamsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParamsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParamsCEParameterParserRuleCall_2_1_1_0 = (RuleCall)cParamsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ComplexEvent:
		//	name=ID '(' (params+=CEParameter (',' params+=CEParameter)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '(' (params+=CEParameter (',' params+=CEParameter)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(params+=CEParameter (',' params+=CEParameter)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//params+=CEParameter
		public Assignment getParamsAssignment_2_0() { return cParamsAssignment_2_0; }
		
		//CEParameter
		public RuleCall getParamsCEParameterParserRuleCall_2_0_0() { return cParamsCEParameterParserRuleCall_2_0_0; }
		
		//(',' params+=CEParameter)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//params+=CEParameter
		public Assignment getParamsAssignment_2_1_1() { return cParamsAssignment_2_1_1; }
		
		//CEParameter
		public RuleCall getParamsCEParameterParserRuleCall_2_1_1_0() { return cParamsCEParameterParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class CEParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.CEParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeReferenceParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//CEParameter:
		//	name=ID ':' type=TypeReference;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' type=TypeReference
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=TypeReference
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//TypeReference
		public RuleCall getTypeTypeReferenceParserRuleCall_2_0() { return cTypeTypeReferenceParserRuleCall_2_0; }
	}
	public class TypeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.TypeReference");
		private final Assignment cPtypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPtypePrimitiveTypeParserRuleCall_0 = (RuleCall)cPtypeAssignment.eContents().get(0);
		
		//TypeReference:
		//	ptype=PrimitiveType;
		@Override public ParserRule getRule() { return rule; }
		
		//ptype=PrimitiveType
		public Assignment getPtypeAssignment() { return cPtypeAssignment; }
		
		//PrimitiveType
		public RuleCall getPtypePrimitiveTypeParserRuleCall_0() { return cPtypePrimitiveTypeParserRuleCall_0; }
	}
	public class PrimitiveTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.PrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegerTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStringTypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRealTypeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PrimitiveType:
		//	IntegerType | BooleanType | StringType | RealType;
		@Override public ParserRule getRule() { return rule; }
		
		//IntegerType | BooleanType | StringType | RealType
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntegerType
		public RuleCall getIntegerTypeParserRuleCall_0() { return cIntegerTypeParserRuleCall_0; }
		
		//BooleanType
		public RuleCall getBooleanTypeParserRuleCall_1() { return cBooleanTypeParserRuleCall_1; }
		
		//StringType
		public RuleCall getStringTypeParserRuleCall_2() { return cStringTypeParserRuleCall_2; }
		
		//RealType
		public RuleCall getRealTypeParserRuleCall_3() { return cRealTypeParserRuleCall_3; }
	}
	public class IntegerTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.IntegerType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntegerTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNameIntegerKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		
		//IntegerType:
		//	{IntegerType} name="integer";
		@Override public ParserRule getRule() { return rule; }
		
		//{IntegerType} name="integer"
		public Group getGroup() { return cGroup; }
		
		//{IntegerType}
		public Action getIntegerTypeAction_0() { return cIntegerTypeAction_0; }
		
		//name="integer"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//"integer"
		public Keyword getNameIntegerKeyword_1_0() { return cNameIntegerKeyword_1_0; }
	}
	public class BooleanTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.BooleanType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBooleanTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNameBooleanKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		
		//BooleanType:
		//	{BooleanType} name="boolean";
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanType} name="boolean"
		public Group getGroup() { return cGroup; }
		
		//{BooleanType}
		public Action getBooleanTypeAction_0() { return cBooleanTypeAction_0; }
		
		//name="boolean"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//"boolean"
		public Keyword getNameBooleanKeyword_1_0() { return cNameBooleanKeyword_1_0; }
	}
	public class StringTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.StringType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStringTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNameStringKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		
		//StringType:
		//	{StringType} name="string";
		@Override public ParserRule getRule() { return rule; }
		
		//{StringType} name="string"
		public Group getGroup() { return cGroup; }
		
		//{StringType}
		public Action getStringTypeAction_0() { return cStringTypeAction_0; }
		
		//name="string"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//"string"
		public Keyword getNameStringKeyword_1_0() { return cNameStringKeyword_1_0; }
	}
	public class RealTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.RealType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRealTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNameRealKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		
		//RealType:
		//	{RealType} name="real";
		@Override public ParserRule getRule() { return rule; }
		
		//{RealType} name="real"
		public Group getGroup() { return cGroup; }
		
		//{RealType}
		public Action getRealTypeAction_0() { return cRealTypeAction_0; }
		
		//name="real"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//"real"
		public Keyword getNameRealKeyword_1_0() { return cNameRealKeyword_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.Expression");
		private final RuleCall cOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	OrExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//OrExpression
		public RuleCall getOrExpressionParserRuleCall() { return cOrExpressionParserRuleCall; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpOrKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//OrExpression Expression:
		//	AndExpression ({OrExpression.lhs=current} op="or" rhs=AndExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression ({OrExpression.lhs=current} op="or" rhs=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//({OrExpression.lhs=current} op="or" rhs=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{OrExpression.lhs=current}
		public Action getOrExpressionLhsAction_1_0() { return cOrExpressionLhsAction_1_0; }
		
		//op="or"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//"or"
		public Keyword getOpOrKeyword_1_1_0() { return cOpOrKeyword_1_1_0; }
		
		//rhs=AndExpression
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//AndExpression
		public RuleCall getRhsAndExpressionParserRuleCall_1_2_0() { return cRhsAndExpressionParserRuleCall_1_2_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAsExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpAndKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsAsExpressionParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//AndExpression Expression:
		//	AsExpression ({AndExpression.lhs=current} op="and" rhs=AsExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AsExpression ({AndExpression.lhs=current} op="and" rhs=AsExpression)*
		public Group getGroup() { return cGroup; }
		
		//AsExpression
		public RuleCall getAsExpressionParserRuleCall_0() { return cAsExpressionParserRuleCall_0; }
		
		//({AndExpression.lhs=current} op="and" rhs=AsExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AndExpression.lhs=current}
		public Action getAndExpressionLhsAction_1_0() { return cAndExpressionLhsAction_1_0; }
		
		//op="and"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//"and"
		public Keyword getOpAndKeyword_1_1_0() { return cOpAndKeyword_1_1_0; }
		
		//rhs=AsExpression
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//AsExpression
		public RuleCall getRhsAsExpressionParserRuleCall_1_2_0() { return cRhsAsExpressionParserRuleCall_1_2_0; }
	}
	public class AsExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.AsExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAsExpressionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpAsKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cNameofasAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cNameofasIDTerminalRuleCall_1_2_0 = (RuleCall)cNameofasAssignment_1_2.eContents().get(0);
		
		//AsExpression Expression:
		//	EqualityExpression ({AsExpression.lhs=current} op="as" nameofas=ID)*
		@Override public ParserRule getRule() { return rule; }
		
		//EqualityExpression ({AsExpression.lhs=current} op="as" nameofas=ID)*
		public Group getGroup() { return cGroup; }
		
		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_0() { return cEqualityExpressionParserRuleCall_0; }
		
		//({AsExpression.lhs=current} op="as" nameofas=ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AsExpression.lhs=current}
		public Action getAsExpressionLhsAction_1_0() { return cAsExpressionLhsAction_1_0; }
		
		//op="as"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//"as"
		public Keyword getOpAsKeyword_1_1_0() { return cOpAsKeyword_1_1_0; }
		
		//nameofas=ID
		public Assignment getNameofasAssignment_1_2() { return cNameofasAssignment_1_2; }
		
		//ID
		public RuleCall getNameofasIDTerminalRuleCall_1_2_0() { return cNameofasIDTerminalRuleCall_1_2_0; }
	}
	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityExpressionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpExclamationMarkEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsRelationalExpressionParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//EqualityExpression Expression:
		//	RelationalExpression ({EqualityExpression.lhs=current} op=("==" | "!=") rhs=RelationalExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//RelationalExpression ({EqualityExpression.lhs=current} op=("==" | "!=") rhs=RelationalExpression)*
		public Group getGroup() { return cGroup; }
		
		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }
		
		//({EqualityExpression.lhs=current} op=("==" | "!=") rhs=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{EqualityExpression.lhs=current}
		public Action getEqualityExpressionLhsAction_1_0() { return cEqualityExpressionLhsAction_1_0; }
		
		//op=("==" | "!=")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//("==" | "!=")
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//"=="
		public Keyword getOpEqualsSignEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignEqualsSignKeyword_1_1_0_0; }
		
		//"!="
		public Keyword getOpExclamationMarkEqualsSignKeyword_1_1_0_1() { return cOpExclamationMarkEqualsSignKeyword_1_1_0_1; }
		
		//rhs=RelationalExpression
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//RelationalExpression
		public RuleCall getRhsRelationalExpressionParserRuleCall_1_2_0() { return cRhsRelationalExpressionParserRuleCall_1_2_0; }
	}
	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparativeExpressionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpLessThanSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//RelationalExpression Expression:
		//	AdditiveExpression ({ComparativeExpression.lhs=current} op=("<" | ">" | "<=" | ">=") rhs=AdditiveExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AdditiveExpression ({ComparativeExpression.lhs=current} op=("<" | ">" | "<=" | ">=") rhs=AdditiveExpression)*
		public Group getGroup() { return cGroup; }
		
		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }
		
		//({ComparativeExpression.lhs=current} op=("<" | ">" | "<=" | ">=") rhs=AdditiveExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ComparativeExpression.lhs=current}
		public Action getComparativeExpressionLhsAction_1_0() { return cComparativeExpressionLhsAction_1_0; }
		
		//op=("<" | ">" | "<=" | ">=")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//("<" | ">" | "<=" | ">=")
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//"<"
		public Keyword getOpLessThanSignKeyword_1_1_0_0() { return cOpLessThanSignKeyword_1_1_0_0; }
		
		//">"
		public Keyword getOpGreaterThanSignKeyword_1_1_0_1() { return cOpGreaterThanSignKeyword_1_1_0_1; }
		
		//"<="
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_2() { return cOpLessThanSignEqualsSignKeyword_1_1_0_2; }
		
		//">="
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_3() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_3; }
		
		//rhs=AdditiveExpression
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//AdditiveExpression
		public RuleCall getRhsAdditiveExpressionParserRuleCall_1_2_0() { return cRhsAdditiveExpressionParserRuleCall_1_2_0; }
	}
	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditiveExpressionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//AdditiveExpression Expression:
		//	MultiplicativeExpression ({AdditiveExpression.lhs=current} op=("+" | "-") rhs=MultiplicativeExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//MultiplicativeExpression ({AdditiveExpression.lhs=current} op=("+" | "-") rhs=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }
		
		//({AdditiveExpression.lhs=current} op=("+" | "-") rhs=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AdditiveExpression.lhs=current}
		public Action getAdditiveExpressionLhsAction_1_0() { return cAdditiveExpressionLhsAction_1_0; }
		
		//op=("+" | "-")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//("+" | "-")
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//"+"
		public Keyword getOpPlusSignKeyword_1_1_0_0() { return cOpPlusSignKeyword_1_1_0_0; }
		
		//"-"
		public Keyword getOpHyphenMinusKeyword_1_1_0_1() { return cOpHyphenMinusKeyword_1_1_0_1; }
		
		//rhs=MultiplicativeExpression
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//MultiplicativeExpression
		public RuleCall getRhsMultiplicativeExpressionParserRuleCall_1_2_0() { return cRhsMultiplicativeExpressionParserRuleCall_1_2_0; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicativeExpressionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsUnaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//MultiplicativeExpression Expression:
		//	UnaryExpression ({MultiplicativeExpression.lhs=current} op=("*" | "/") rhs=UnaryExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryExpression ({MultiplicativeExpression.lhs=current} op=("*" | "/") rhs=UnaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }
		
		//({MultiplicativeExpression.lhs=current} op=("*" | "/") rhs=UnaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{MultiplicativeExpression.lhs=current}
		public Action getMultiplicativeExpressionLhsAction_1_0() { return cMultiplicativeExpressionLhsAction_1_0; }
		
		//op=("*" | "/")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//("*" | "/")
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//"*"
		public Keyword getOpAsteriskKeyword_1_1_0_0() { return cOpAsteriskKeyword_1_1_0_0; }
		
		//"/"
		public Keyword getOpSolidusKeyword_1_1_0_1() { return cOpSolidusKeyword_1_1_0_1; }
		
		//rhs=UnaryExpression
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }
		
		//UnaryExpression
		public RuleCall getRhsUnaryExpressionParserRuleCall_1_2_0() { return cRhsUnaryExpressionParserRuleCall_1_2_0; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNotExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cOpNotKeyword_0_1_0 = (Keyword)cOpAssignment_0_1.eContents().get(0);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandUnaryExpressionParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPlusExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpPlusSignKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperandUnaryExpressionParserRuleCall_1_2_0 = (RuleCall)cOperandAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cMinusExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cOpAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Keyword cOpHyphenMinusKeyword_2_1_0 = (Keyword)cOpAssignment_2_1.eContents().get(0);
		private final Assignment cOperandAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cOperandUnaryExpressionParserRuleCall_2_2_0 = (RuleCall)cOperandAssignment_2_2.eContents().get(0);
		private final RuleCall cPrimaryExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//UnaryExpression Expression:
		//	{NotExpression} op="not" operand=UnaryExpression | {PlusExpression} op="+" operand=UnaryExpression |
		//	{MinusExpression} op="-" operand=UnaryExpression | PrimaryExpression
		@Override public ParserRule getRule() { return rule; }
		
		//{NotExpression} op="not" operand=UnaryExpression | {PlusExpression} op="+" operand=UnaryExpression | {MinusExpression}
		//op="-" operand=UnaryExpression | PrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{NotExpression} op="not" operand=UnaryExpression
		public Group getGroup_0() { return cGroup_0; }
		
		//{NotExpression}
		public Action getNotExpressionAction_0_0() { return cNotExpressionAction_0_0; }
		
		//op="not"
		public Assignment getOpAssignment_0_1() { return cOpAssignment_0_1; }
		
		//"not"
		public Keyword getOpNotKeyword_0_1_0() { return cOpNotKeyword_0_1_0; }
		
		//operand=UnaryExpression
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }
		
		//UnaryExpression
		public RuleCall getOperandUnaryExpressionParserRuleCall_0_2_0() { return cOperandUnaryExpressionParserRuleCall_0_2_0; }
		
		//{PlusExpression} op="+" operand=UnaryExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{PlusExpression}
		public Action getPlusExpressionAction_1_0() { return cPlusExpressionAction_1_0; }
		
		//op="+"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//"+"
		public Keyword getOpPlusSignKeyword_1_1_0() { return cOpPlusSignKeyword_1_1_0; }
		
		//operand=UnaryExpression
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//UnaryExpression
		public RuleCall getOperandUnaryExpressionParserRuleCall_1_2_0() { return cOperandUnaryExpressionParserRuleCall_1_2_0; }
		
		//{MinusExpression} op="-" operand=UnaryExpression
		public Group getGroup_2() { return cGroup_2; }
		
		//{MinusExpression}
		public Action getMinusExpressionAction_2_0() { return cMinusExpressionAction_2_0; }
		
		//op="-"
		public Assignment getOpAssignment_2_1() { return cOpAssignment_2_1; }
		
		//"-"
		public Keyword getOpHyphenMinusKeyword_2_1_0() { return cOpHyphenMinusKeyword_2_1_0; }
		
		//operand=UnaryExpression
		public Assignment getOperandAssignment_2_2() { return cOperandAssignment_2_2; }
		
		//UnaryExpression
		public RuleCall getOperandUnaryExpressionParserRuleCall_2_2_0() { return cOperandUnaryExpressionParserRuleCall_2_2_0; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_3() { return cPrimaryExpressionParserRuleCall_3; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParenthesizedExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PrimaryExpression Expression:
		//	ParenthesizedExpression | LiteralExpression
		@Override public ParserRule getRule() { return rule; }
		
		//ParenthesizedExpression | LiteralExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ParenthesizedExpression
		public RuleCall getParenthesizedExpressionParserRuleCall_0() { return cParenthesizedExpressionParserRuleCall_0; }
		
		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_1() { return cLiteralExpressionParserRuleCall_1; }
	}
	public class ParenthesizedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.ParenthesizedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenthesizedExpression Expression:
		//	'(' Expression ')'
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cep.Cep.LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIntegerLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cStringLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cBooleanLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Keyword cFalseKeyword_2_1_0 = (Keyword)cAlternatives_2_1.eContents().get(0);
		private final Assignment cIsTrueAssignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final Keyword cIsTrueTrueKeyword_2_1_1_0 = (Keyword)cIsTrueAssignment_2_1_1.eContents().get(0);
		
		//LiteralExpression:
		//	{IntegerLiteral} value=INT | {StringLiteral} value=STRING | {BooleanLiteral} ('false' | isTrue?='true');
		@Override public ParserRule getRule() { return rule; }
		
		//{IntegerLiteral} value=INT | {StringLiteral} value=STRING | {BooleanLiteral} ('false' | isTrue?='true')
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{IntegerLiteral} value=INT
		public Group getGroup_0() { return cGroup_0; }
		
		//{IntegerLiteral}
		public Action getIntegerLiteralAction_0_0() { return cIntegerLiteralAction_0_0; }
		
		//value=INT
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0_1_0() { return cValueINTTerminalRuleCall_0_1_0; }
		
		//{StringLiteral} value=STRING
		public Group getGroup_1() { return cGroup_1; }
		
		//{StringLiteral}
		public Action getStringLiteralAction_1_0() { return cStringLiteralAction_1_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_1_0() { return cValueSTRINGTerminalRuleCall_1_1_0; }
		
		//{BooleanLiteral} ('false' | isTrue?='true')
		public Group getGroup_2() { return cGroup_2; }
		
		//{BooleanLiteral}
		public Action getBooleanLiteralAction_2_0() { return cBooleanLiteralAction_2_0; }
		
		//('false' | isTrue?='true')
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }
		
		//'false'
		public Keyword getFalseKeyword_2_1_0() { return cFalseKeyword_2_1_0; }
		
		//isTrue?='true'
		public Assignment getIsTrueAssignment_2_1_1() { return cIsTrueAssignment_2_1_1; }
		
		//'true'
		public Keyword getIsTrueTrueKeyword_2_1_1_0() { return cIsTrueTrueKeyword_2_1_1_0; }
	}
	
	
	private final ModelElements pModel;
	private final RuleElements pRule;
	private final ComplexEventElements pComplexEvent;
	private final CEParameterElements pCEParameter;
	private final TypeReferenceElements pTypeReference;
	private final PrimitiveTypeElements pPrimitiveType;
	private final IntegerTypeElements pIntegerType;
	private final BooleanTypeElements pBooleanType;
	private final StringTypeElements pStringType;
	private final RealTypeElements pRealType;
	private final ExpressionElements pExpression;
	private final OrExpressionElements pOrExpression;
	private final AndExpressionElements pAndExpression;
	private final AsExpressionElements pAsExpression;
	private final EqualityExpressionElements pEqualityExpression;
	private final RelationalExpressionElements pRelationalExpression;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final UnaryExpressionElements pUnaryExpression;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final ParenthesizedExpressionElements pParenthesizedExpression;
	private final LiteralExpressionElements pLiteralExpression;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public CepGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pRule = new RuleElements();
		this.pComplexEvent = new ComplexEventElements();
		this.pCEParameter = new CEParameterElements();
		this.pTypeReference = new TypeReferenceElements();
		this.pPrimitiveType = new PrimitiveTypeElements();
		this.pIntegerType = new IntegerTypeElements();
		this.pBooleanType = new BooleanTypeElements();
		this.pStringType = new StringTypeElements();
		this.pRealType = new RealTypeElements();
		this.pExpression = new ExpressionElements();
		this.pOrExpression = new OrExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pAsExpression = new AsExpressionElements();
		this.pEqualityExpression = new EqualityExpressionElements();
		this.pRelationalExpression = new RelationalExpressionElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pParenthesizedExpression = new ParenthesizedExpressionElements();
		this.pLiteralExpression = new LiteralExpressionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.cep.Cep".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	rule+=Rule*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	/// * mode de test * / Rule:
	//	'Define' ComplexEvent
	//	'From' Pattern=Expression
	//	'Where' conditionExpression=ID ';'
	//	// 'consuming'  listOfConsumption  
	//;
	public RuleElements getRuleAccess() {
		return pRule;
	}
	
	public ParserRule getRuleRule() {
		return getRuleAccess().getRule();
	}
	
	//ComplexEvent:
	//	name=ID '(' (params+=CEParameter (',' params+=CEParameter)*)? ')';
	public ComplexEventElements getComplexEventAccess() {
		return pComplexEvent;
	}
	
	public ParserRule getComplexEventRule() {
		return getComplexEventAccess().getRule();
	}
	
	//CEParameter:
	//	name=ID ':' type=TypeReference;
	public CEParameterElements getCEParameterAccess() {
		return pCEParameter;
	}
	
	public ParserRule getCEParameterRule() {
		return getCEParameterAccess().getRule();
	}
	
	//TypeReference:
	//	ptype=PrimitiveType;
	public TypeReferenceElements getTypeReferenceAccess() {
		return pTypeReference;
	}
	
	public ParserRule getTypeReferenceRule() {
		return getTypeReferenceAccess().getRule();
	}
	
	//PrimitiveType:
	//	IntegerType | BooleanType | StringType | RealType;
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return pPrimitiveType;
	}
	
	public ParserRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}
	
	//IntegerType:
	//	{IntegerType} name="integer";
	public IntegerTypeElements getIntegerTypeAccess() {
		return pIntegerType;
	}
	
	public ParserRule getIntegerTypeRule() {
		return getIntegerTypeAccess().getRule();
	}
	
	//BooleanType:
	//	{BooleanType} name="boolean";
	public BooleanTypeElements getBooleanTypeAccess() {
		return pBooleanType;
	}
	
	public ParserRule getBooleanTypeRule() {
		return getBooleanTypeAccess().getRule();
	}
	
	//StringType:
	//	{StringType} name="string";
	public StringTypeElements getStringTypeAccess() {
		return pStringType;
	}
	
	public ParserRule getStringTypeRule() {
		return getStringTypeAccess().getRule();
	}
	
	//RealType:
	//	{RealType} name="real";
	public RealTypeElements getRealTypeAccess() {
		return pRealType;
	}
	
	public ParserRule getRealTypeRule() {
		return getRealTypeAccess().getRule();
	}
	
	//Expression:
	//	OrExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//OrExpression Expression:
	//	AndExpression ({OrExpression.lhs=current} op="or" rhs=AndExpression)*
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//AndExpression Expression:
	//	AsExpression ({AndExpression.lhs=current} op="and" rhs=AsExpression)*
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//AsExpression Expression:
	//	EqualityExpression ({AsExpression.lhs=current} op="as" nameofas=ID)*
	public AsExpressionElements getAsExpressionAccess() {
		return pAsExpression;
	}
	
	public ParserRule getAsExpressionRule() {
		return getAsExpressionAccess().getRule();
	}
	
	//EqualityExpression Expression:
	//	RelationalExpression ({EqualityExpression.lhs=current} op=("==" | "!=") rhs=RelationalExpression)*
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return pEqualityExpression;
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}
	
	//RelationalExpression Expression:
	//	AdditiveExpression ({ComparativeExpression.lhs=current} op=("<" | ">" | "<=" | ">=") rhs=AdditiveExpression)*
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return pRelationalExpression;
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}
	
	//AdditiveExpression Expression:
	//	MultiplicativeExpression ({AdditiveExpression.lhs=current} op=("+" | "-") rhs=MultiplicativeExpression)*
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}
	
	//MultiplicativeExpression Expression:
	//	UnaryExpression ({MultiplicativeExpression.lhs=current} op=("*" | "/") rhs=UnaryExpression)*
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//UnaryExpression Expression:
	//	{NotExpression} op="not" operand=UnaryExpression | {PlusExpression} op="+" operand=UnaryExpression |
	//	{MinusExpression} op="-" operand=UnaryExpression | PrimaryExpression
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//PrimaryExpression Expression:
	//	ParenthesizedExpression | LiteralExpression
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	//ParenthesizedExpression Expression:
	//	'(' Expression ')'
	public ParenthesizedExpressionElements getParenthesizedExpressionAccess() {
		return pParenthesizedExpression;
	}
	
	public ParserRule getParenthesizedExpressionRule() {
		return getParenthesizedExpressionAccess().getRule();
	}
	
	//LiteralExpression:
	//	{IntegerLiteral} value=INT | {StringLiteral} value=STRING | {BooleanLiteral} ('false' | isTrue?='true');
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return pLiteralExpression;
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
