/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.cep.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.cep.cep.AdditiveExpression;
import org.xtext.example.cep.cep.AndExpression;
import org.xtext.example.cep.cep.AsExpression;
import org.xtext.example.cep.cep.BooleanLiteral;
import org.xtext.example.cep.cep.BooleanType;
import org.xtext.example.cep.cep.CEParameter;
import org.xtext.example.cep.cep.CepPackage;
import org.xtext.example.cep.cep.ComparativeExpression;
import org.xtext.example.cep.cep.ComplexEvent;
import org.xtext.example.cep.cep.EqualityExpression;
import org.xtext.example.cep.cep.IntegerLiteral;
import org.xtext.example.cep.cep.IntegerType;
import org.xtext.example.cep.cep.MinusExpression;
import org.xtext.example.cep.cep.Model;
import org.xtext.example.cep.cep.MultiplicativeExpression;
import org.xtext.example.cep.cep.NotExpression;
import org.xtext.example.cep.cep.OrExpression;
import org.xtext.example.cep.cep.PlusExpression;
import org.xtext.example.cep.cep.RealType;
import org.xtext.example.cep.cep.StringLiteral;
import org.xtext.example.cep.cep.StringType;
import org.xtext.example.cep.cep.TypeReference;
import org.xtext.example.cep.services.CepGrammarAccess;

@SuppressWarnings("all")
public class CepSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CepGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CepPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CepPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case CepPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case CepPackage.AS_EXPRESSION:
				sequence_AsExpression(context, (AsExpression) semanticObject); 
				return; 
			case CepPackage.BOOLEAN_LITERAL:
				sequence_LiteralExpression(context, (BooleanLiteral) semanticObject); 
				return; 
			case CepPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case CepPackage.CE_PARAMETER:
				sequence_CEParameter(context, (CEParameter) semanticObject); 
				return; 
			case CepPackage.COMPARATIVE_EXPRESSION:
				sequence_RelationalExpression(context, (ComparativeExpression) semanticObject); 
				return; 
			case CepPackage.COMPLEX_EVENT:
				if (rule == grammarAccess.getComplexEventRule()) {
					sequence_ComplexEvent(context, (ComplexEvent) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRuleRule()) {
					sequence_ComplexEvent_Rule(context, (ComplexEvent) semanticObject); 
					return; 
				}
				else break;
			case CepPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case CepPackage.INTEGER_LITERAL:
				sequence_LiteralExpression(context, (IntegerLiteral) semanticObject); 
				return; 
			case CepPackage.INTEGER_TYPE:
				sequence_IntegerType(context, (IntegerType) semanticObject); 
				return; 
			case CepPackage.MINUS_EXPRESSION:
				sequence_UnaryExpression(context, (MinusExpression) semanticObject); 
				return; 
			case CepPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CepPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case CepPackage.NOT_EXPRESSION:
				sequence_UnaryExpression(context, (NotExpression) semanticObject); 
				return; 
			case CepPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case CepPackage.PLUS_EXPRESSION:
				sequence_UnaryExpression(context, (PlusExpression) semanticObject); 
				return; 
			case CepPackage.REAL_TYPE:
				sequence_RealType(context, (RealType) semanticObject); 
				return; 
			case CepPackage.STRING_LITERAL:
				sequence_LiteralExpression(context, (StringLiteral) semanticObject); 
				return; 
			case CepPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case CepPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AdditiveExpression
	 *     OrExpression returns AdditiveExpression
	 *     OrExpression.OrExpression_1_0 returns AdditiveExpression
	 *     AndExpression returns AdditiveExpression
	 *     AndExpression.AndExpression_1_0 returns AdditiveExpression
	 *     AsExpression returns AdditiveExpression
	 *     AsExpression.AsExpression_1_0 returns AdditiveExpression
	 *     EqualityExpression returns AdditiveExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns AdditiveExpression
	 *     RelationalExpression returns AdditiveExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns AdditiveExpression
	 *     AdditiveExpression returns AdditiveExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns AdditiveExpression
	 *     MultiplicativeExpression returns AdditiveExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns AdditiveExpression
	 *     UnaryExpression returns AdditiveExpression
	 *     PrimaryExpression returns AdditiveExpression
	 *     ParenthesizedExpression returns AdditiveExpression
	 *
	 * Constraint:
	 *     (lhs=AdditiveExpression_AdditiveExpression_1_0 (op='+' | op='-') rhs=MultiplicativeExpression)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     AsExpression returns AndExpression
	 *     AsExpression.AsExpression_1_0 returns AndExpression
	 *     EqualityExpression returns AndExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns AndExpression
	 *     RelationalExpression returns AndExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns AndExpression
	 *     AdditiveExpression returns AndExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns AndExpression
	 *     MultiplicativeExpression returns AndExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns AndExpression
	 *     UnaryExpression returns AndExpression
	 *     PrimaryExpression returns AndExpression
	 *     ParenthesizedExpression returns AndExpression
	 *
	 * Constraint:
	 *     (lhs=AndExpression_AndExpression_1_0 op='and' rhs=AsExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.AND_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.AND_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.AND_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.AND_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.AND_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.AND_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAndExpressionAccess().getOpAndKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRhsAsExpressionParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AsExpression
	 *     OrExpression returns AsExpression
	 *     OrExpression.OrExpression_1_0 returns AsExpression
	 *     AndExpression returns AsExpression
	 *     AndExpression.AndExpression_1_0 returns AsExpression
	 *     AsExpression returns AsExpression
	 *     AsExpression.AsExpression_1_0 returns AsExpression
	 *     EqualityExpression returns AsExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns AsExpression
	 *     RelationalExpression returns AsExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns AsExpression
	 *     AdditiveExpression returns AsExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns AsExpression
	 *     MultiplicativeExpression returns AsExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns AsExpression
	 *     UnaryExpression returns AsExpression
	 *     PrimaryExpression returns AsExpression
	 *     ParenthesizedExpression returns AsExpression
	 *
	 * Constraint:
	 *     (lhs=AsExpression_AsExpression_1_0 op='as' nameofas=ID)
	 */
	protected void sequence_AsExpression(ISerializationContext context, AsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.AS_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.AS_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.AS_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.AS_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.AS_EXPRESSION__NAMEOFAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.AS_EXPRESSION__NAMEOFAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsExpressionAccess().getAsExpressionLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAsExpressionAccess().getOpAsKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAsExpressionAccess().getNameofasIDTerminalRuleCall_1_2_0(), semanticObject.getNameofas());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimitiveType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     name='boolean'
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.PRIMITIVE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.PRIMITIVE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanTypeAccess().getNameBooleanKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CEParameter returns CEParameter
	 *
	 * Constraint:
	 *     (name=ID type=TypeReference)
	 */
	protected void sequence_CEParameter(ISerializationContext context, CEParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.CE_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.CE_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.CE_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.CE_PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCEParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCEParameterAccess().getTypeTypeReferenceParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComplexEvent returns ComplexEvent
	 *
	 * Constraint:
	 *     (name=ID (params+=CEParameter params+=CEParameter*)?)
	 */
	protected void sequence_ComplexEvent(ISerializationContext context, ComplexEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns ComplexEvent
	 *
	 * Constraint:
	 *     (name=ID (params+=CEParameter params+=CEParameter*)? Pattern=Expression conditionExpression=ID)
	 */
	protected void sequence_ComplexEvent_Rule(ISerializationContext context, ComplexEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EqualityExpression
	 *     OrExpression returns EqualityExpression
	 *     OrExpression.OrExpression_1_0 returns EqualityExpression
	 *     AndExpression returns EqualityExpression
	 *     AndExpression.AndExpression_1_0 returns EqualityExpression
	 *     AsExpression returns EqualityExpression
	 *     AsExpression.AsExpression_1_0 returns EqualityExpression
	 *     EqualityExpression returns EqualityExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns EqualityExpression
	 *     RelationalExpression returns EqualityExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns EqualityExpression
	 *     AdditiveExpression returns EqualityExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns EqualityExpression
	 *     MultiplicativeExpression returns EqualityExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns EqualityExpression
	 *     UnaryExpression returns EqualityExpression
	 *     PrimaryExpression returns EqualityExpression
	 *     ParenthesizedExpression returns EqualityExpression
	 *
	 * Constraint:
	 *     (lhs=EqualityExpression_EqualityExpression_1_0 (op='==' | op='!=') rhs=RelationalExpression)
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimitiveType returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     name='integer'
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.PRIMITIVE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.PRIMITIVE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerTypeAccess().getNameIntegerKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.OrExpression_1_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.AndExpression_1_0 returns BooleanLiteral
	 *     AsExpression returns BooleanLiteral
	 *     AsExpression.AsExpression_1_0 returns BooleanLiteral
	 *     EqualityExpression returns BooleanLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns BooleanLiteral
	 *     RelationalExpression returns BooleanLiteral
	 *     RelationalExpression.ComparativeExpression_1_0 returns BooleanLiteral
	 *     AdditiveExpression returns BooleanLiteral
	 *     AdditiveExpression.AdditiveExpression_1_0 returns BooleanLiteral
	 *     MultiplicativeExpression returns BooleanLiteral
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns BooleanLiteral
	 *     UnaryExpression returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     ParenthesizedExpression returns BooleanLiteral
	 *     LiteralExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     isTrue?='true'?
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerLiteral
	 *     OrExpression returns IntegerLiteral
	 *     OrExpression.OrExpression_1_0 returns IntegerLiteral
	 *     AndExpression returns IntegerLiteral
	 *     AndExpression.AndExpression_1_0 returns IntegerLiteral
	 *     AsExpression returns IntegerLiteral
	 *     AsExpression.AsExpression_1_0 returns IntegerLiteral
	 *     EqualityExpression returns IntegerLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns IntegerLiteral
	 *     RelationalExpression returns IntegerLiteral
	 *     RelationalExpression.ComparativeExpression_1_0 returns IntegerLiteral
	 *     AdditiveExpression returns IntegerLiteral
	 *     AdditiveExpression.AdditiveExpression_1_0 returns IntegerLiteral
	 *     MultiplicativeExpression returns IntegerLiteral
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns IntegerLiteral
	 *     UnaryExpression returns IntegerLiteral
	 *     PrimaryExpression returns IntegerLiteral
	 *     ParenthesizedExpression returns IntegerLiteral
	 *     LiteralExpression returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.OrExpression_1_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.AndExpression_1_0 returns StringLiteral
	 *     AsExpression returns StringLiteral
	 *     AsExpression.AsExpression_1_0 returns StringLiteral
	 *     EqualityExpression returns StringLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns StringLiteral
	 *     RelationalExpression returns StringLiteral
	 *     RelationalExpression.ComparativeExpression_1_0 returns StringLiteral
	 *     AdditiveExpression returns StringLiteral
	 *     AdditiveExpression.AdditiveExpression_1_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     ParenthesizedExpression returns StringLiteral
	 *     LiteralExpression returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     rule+=Rule+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MultiplicativeExpression
	 *     OrExpression returns MultiplicativeExpression
	 *     OrExpression.OrExpression_1_0 returns MultiplicativeExpression
	 *     AndExpression returns MultiplicativeExpression
	 *     AndExpression.AndExpression_1_0 returns MultiplicativeExpression
	 *     AsExpression returns MultiplicativeExpression
	 *     AsExpression.AsExpression_1_0 returns MultiplicativeExpression
	 *     EqualityExpression returns MultiplicativeExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MultiplicativeExpression
	 *     RelationalExpression returns MultiplicativeExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns MultiplicativeExpression
	 *     AdditiveExpression returns MultiplicativeExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns MultiplicativeExpression
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns MultiplicativeExpression
	 *     UnaryExpression returns MultiplicativeExpression
	 *     PrimaryExpression returns MultiplicativeExpression
	 *     ParenthesizedExpression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (lhs=MultiplicativeExpression_MultiplicativeExpression_1_0 (op='*' | op='/') rhs=UnaryExpression)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     AsExpression returns OrExpression
	 *     AsExpression.AsExpression_1_0 returns OrExpression
	 *     EqualityExpression returns OrExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns OrExpression
	 *     RelationalExpression returns OrExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns OrExpression
	 *     AdditiveExpression returns OrExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns OrExpression
	 *     MultiplicativeExpression returns OrExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns OrExpression
	 *     UnaryExpression returns OrExpression
	 *     PrimaryExpression returns OrExpression
	 *     ParenthesizedExpression returns OrExpression
	 *
	 * Constraint:
	 *     (lhs=OrExpression_OrExpression_1_0 op='or' rhs=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.OR_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.OR_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.OR_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.OR_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.OR_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.OR_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getOrExpressionAccess().getOpOrKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRhsAndExpressionParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimitiveType returns RealType
	 *     RealType returns RealType
	 *
	 * Constraint:
	 *     name='real'
	 */
	protected void sequence_RealType(ISerializationContext context, RealType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.PRIMITIVE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.PRIMITIVE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealTypeAccess().getNameRealKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComparativeExpression
	 *     OrExpression returns ComparativeExpression
	 *     OrExpression.OrExpression_1_0 returns ComparativeExpression
	 *     AndExpression returns ComparativeExpression
	 *     AndExpression.AndExpression_1_0 returns ComparativeExpression
	 *     AsExpression returns ComparativeExpression
	 *     AsExpression.AsExpression_1_0 returns ComparativeExpression
	 *     EqualityExpression returns ComparativeExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns ComparativeExpression
	 *     RelationalExpression returns ComparativeExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns ComparativeExpression
	 *     AdditiveExpression returns ComparativeExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns ComparativeExpression
	 *     MultiplicativeExpression returns ComparativeExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns ComparativeExpression
	 *     UnaryExpression returns ComparativeExpression
	 *     PrimaryExpression returns ComparativeExpression
	 *     ParenthesizedExpression returns ComparativeExpression
	 *
	 * Constraint:
	 *     (lhs=RelationalExpression_ComparativeExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') rhs=AdditiveExpression)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, ComparativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimitiveType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     name='string'
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.PRIMITIVE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.PRIMITIVE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTypeAccess().getNameStringKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     ptype=PrimitiveType
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.TYPE_REFERENCE__PTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.TYPE_REFERENCE__PTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeReferenceAccess().getPtypePrimitiveTypeParserRuleCall_0(), semanticObject.getPtype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinusExpression
	 *     OrExpression returns MinusExpression
	 *     OrExpression.OrExpression_1_0 returns MinusExpression
	 *     AndExpression returns MinusExpression
	 *     AndExpression.AndExpression_1_0 returns MinusExpression
	 *     AsExpression returns MinusExpression
	 *     AsExpression.AsExpression_1_0 returns MinusExpression
	 *     EqualityExpression returns MinusExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MinusExpression
	 *     RelationalExpression returns MinusExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns MinusExpression
	 *     AdditiveExpression returns MinusExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns MinusExpression
	 *     MultiplicativeExpression returns MinusExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns MinusExpression
	 *     UnaryExpression returns MinusExpression
	 *     PrimaryExpression returns MinusExpression
	 *     ParenthesizedExpression returns MinusExpression
	 *
	 * Constraint:
	 *     (op='-' operand=UnaryExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, MinusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.MINUS_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.MINUS_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.MINUS_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.MINUS_EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOpHyphenMinusKeyword_2_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOperandUnaryExpressionParserRuleCall_2_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     OrExpression returns NotExpression
	 *     OrExpression.OrExpression_1_0 returns NotExpression
	 *     AndExpression returns NotExpression
	 *     AndExpression.AndExpression_1_0 returns NotExpression
	 *     AsExpression returns NotExpression
	 *     AsExpression.AsExpression_1_0 returns NotExpression
	 *     EqualityExpression returns NotExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns NotExpression
	 *     RelationalExpression returns NotExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns NotExpression
	 *     AdditiveExpression returns NotExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns NotExpression
	 *     MultiplicativeExpression returns NotExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns NotExpression
	 *     UnaryExpression returns NotExpression
	 *     PrimaryExpression returns NotExpression
	 *     ParenthesizedExpression returns NotExpression
	 *
	 * Constraint:
	 *     (op='not' operand=UnaryExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.NOT_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.NOT_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.NOT_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.NOT_EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOpNotKeyword_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOperandUnaryExpressionParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PlusExpression
	 *     OrExpression returns PlusExpression
	 *     OrExpression.OrExpression_1_0 returns PlusExpression
	 *     AndExpression returns PlusExpression
	 *     AndExpression.AndExpression_1_0 returns PlusExpression
	 *     AsExpression returns PlusExpression
	 *     AsExpression.AsExpression_1_0 returns PlusExpression
	 *     EqualityExpression returns PlusExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns PlusExpression
	 *     RelationalExpression returns PlusExpression
	 *     RelationalExpression.ComparativeExpression_1_0 returns PlusExpression
	 *     AdditiveExpression returns PlusExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns PlusExpression
	 *     MultiplicativeExpression returns PlusExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns PlusExpression
	 *     UnaryExpression returns PlusExpression
	 *     PrimaryExpression returns PlusExpression
	 *     ParenthesizedExpression returns PlusExpression
	 *
	 * Constraint:
	 *     (op='+' operand=UnaryExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, PlusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.PLUS_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.PLUS_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, CepPackage.Literals.PLUS_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CepPackage.Literals.PLUS_EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOpPlusSignKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOperandUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
}
