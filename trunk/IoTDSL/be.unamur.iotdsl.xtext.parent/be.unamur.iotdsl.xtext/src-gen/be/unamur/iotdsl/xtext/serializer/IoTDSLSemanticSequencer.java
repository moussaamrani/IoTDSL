/*
 * generated by Xtext 2.10.0
 */
package be.unamur.iotdsl.xtext.serializer;

import be.unamur.iotdsl.xtext.services.IoTDSLGrammarAccess;
import com.google.inject.Inject;
import iotdsl.BooleanType;
import iotdsl.Device;
import iotdsl.Enumeration;
import iotdsl.EnumerationLiteral;
import iotdsl.Event;
import iotdsl.Gateway;
import iotdsl.IntegerType;
import iotdsl.IoTDSLPackage;
import iotdsl.IoTModel;
import iotdsl.Property;
import iotdsl.RealType;
import iotdsl.StringType;
import iotdsl.TypeReference;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IoTDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IoTDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IoTDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IoTDSLPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case IoTDSLPackage.DEVICE:
				sequence_Device(context, (Device) semanticObject); 
				return; 
			case IoTDSLPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case IoTDSLPackage.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case IoTDSLPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case IoTDSLPackage.GATEWAY:
				sequence_Gateway(context, (Gateway) semanticObject); 
				return; 
			case IoTDSLPackage.INTEGER_TYPE:
				sequence_IntegerType(context, (IntegerType) semanticObject); 
				return; 
			case IoTDSLPackage.IO_TMODEL:
				sequence_IoTModel(context, (IoTModel) semanticObject); 
				return; 
			case IoTDSLPackage.PARAMETER:
				sequence_Parameter(context, (iotdsl.Parameter) semanticObject); 
				return; 
			case IoTDSLPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case IoTDSLPackage.REAL_TYPE:
				sequence_RealType(context, (RealType) semanticObject); 
				return; 
			case IoTDSLPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case IoTDSLPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     NamedElement returns BooleanType
	 *     Type returns BooleanType
	 *     PrimitiveType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     name='boolean'
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanTypeAccess().getNameBooleanKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Device
	 *     Type returns Device
	 *     DeclaredType returns Device
	 *     Node returns Device
	 *     Device returns Device
	 *
	 * Constraint:
	 *     (name=ValidID features+=Feature*)
	 */
	protected void sequence_Device(ISerializationContext context, Device semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns EnumerationLiteral
	 *     EnumerationLiteral returns EnumerationLiteral
	 *
	 * Constraint:
	 *     name=ValidID
	 */
	protected void sequence_EnumerationLiteral(ISerializationContext context, EnumerationLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationLiteralAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Enumeration
	 *     Type returns Enumeration
	 *     DeclaredType returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=ValidID literals+=EnumerationLiteral*)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Event
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (kind=EventType name=ValidID (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Gateway
	 *     Type returns Gateway
	 *     DeclaredType returns Gateway
	 *     Node returns Gateway
	 *     Gateway returns Gateway
	 *
	 * Constraint:
	 *     name=ValidID
	 */
	protected void sequence_Gateway(ISerializationContext context, Gateway semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGatewayAccess().getNameValidIDParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns IntegerType
	 *     Type returns IntegerType
	 *     PrimitiveType returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     name='integer'
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerTypeAccess().getNameIntegerKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IoTModel returns IoTModel
	 *
	 * Constraint:
	 *     types+=Type*
	 */
	protected void sequence_IoTModel(ISerializationContext context, IoTModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Parameter
	 *     NamedTypedElement returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ValidID type=TypeReference)
	 */
	protected void sequence_Parameter(ISerializationContext context, iotdsl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameValidIDParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeReferenceParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Property
	 *     NamedTypedElement returns Property
	 *     Feature returns Property
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=ValidID type=TypeReference)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyAccess().getTypeTypeReferenceParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns RealType
	 *     Type returns RealType
	 *     PrimitiveType returns RealType
	 *     RealType returns RealType
	 *
	 * Constraint:
	 *     name='real'
	 */
	protected void sequence_RealType(ISerializationContext context, RealType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealTypeAccess().getNameRealKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns StringType
	 *     Type returns StringType
	 *     PrimitiveType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     name='string'
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IoTDSLPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTypeAccess().getNameStringKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     (ptype=PrimitiveType | dtype=[DeclaredType|QualifiedName])
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
