\subsection{TRex as \CEP engine}
\label{sec:CG-TRex}

To permit efficient event processing from distributed connected things, we rely on TRex, a powerful and highly optimised \CEP engine developed by Cugola and Margara~\cite{cugola-12}. TRex relies on Tesla \cite{Cugola-Margara:2010}, an entry language that is expressive enough to address most of the necessary patterns for capturing complex events definitions. As a consequence, the expression language used for triggers in our business rules is directly inspired from Tesla. This allows us to offer end-users the expressibility they need, while at the same time simplifying the translation of \IOTDSL rules into Tesla rules. TRex offers a queueing mechanism to overcome bursts of incoming events: when deploying the \IOT system on site, it becomes possible to customise the queue size, thus balancing between event loss and treatment latency. 

TRex is conveniently organised as a Client/Server architecture in a \textit{<<publish / subscribe>>} way: on the server side, event notifications are received at runtime, and processed according to a set of rules defined in the Tesla language, resulting in the production of a hierarchy of complex events that could be reused internally, whereas clients subscribe to the server with the event notifications they are interested in. Note that the server is interactive so that clients can (un-)subscribe while the engine is running and rules may be added or deleted at runtime without affecting the overall infrastructure. 

From the perspective of \IOTDSL, TRex offers several benefits as a \CEP engine middleware: TRex is powerful enough to handle typical \IOT scenarios like the one described in Section \ref{sec:Motivation}, thanks to the expressive power of Tesla. It adopts a decentralised architecture that directly reflects our design choices, and supports distributed processing of events to reduce the cost of communication and to optimise resource usage. It is developed in C, so it is even suitable for \textit{small form factor} middlewares. Finally, on top of a C \textsc{API}, Java libraries have been developed on which we rely to generate devices' simulation code.
