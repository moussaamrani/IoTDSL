\subsection{TRex as \CEP engine}
\label{sec:CG-TRex}

To permit efficient event processing from distributed connected things, we rely on TRex, a powerful and highly optimised \CEP engine developed by Cugola and Margara~\cite{cugola-12}. TRex relies on Tesla \cite{Cugola-Margara:2010}, an entry language that is expressive enough to address most of the necessary patterns for capturing complex events definitions. As a consequence, the expression language used for triggers in our business rules is directly inspired from Tesla. This allows us to offer end-users the expressibility they need, while at the same time simplifying the translation of \IOTDSL rules into Tesla rules. TRex offers a queueing mechanism to overcome bursts of incoming events: when deploying the \IOT system on site, it becomes possible to customise the queue size, thus balancing between event loss and treatment latency. 

TRex is conveniently organised as a Client/Server architecture in a \textit{<<publish / subscribe>>} way, and relies on the Tesla language to define the necessary components: event \emph{notifications} (or \emph{occurences}, or simply events); \emph{subscriptions} and \emph{rules}. TRex, as the \CEP engine, permanently receives event notifications from sources, and redistribute them to subscribers. 
An event notification is produced by a source and sent to the \CEP system, and is typed by an event type that possesses typed attributes: for example, \lstinline[language=tesla]{Temp@100(location = ``Living'', value = 25.0)} defines a notification of type \lstinline[language=tesla]{Temp} with two attributes and a timestamp (noted after the \lstinline[language=tesla]{@}) that records the moment in time the notification is produced. A subscription by sinks (or, event consumers) is submitted to the \CEP system in order to receive notifications that things happened: for example, \lstinline[language=tesla]{Subscribe(Temp, location = ``Living'' and value > 20)} indicates a subscription to \lstinline[language=tesla]{Temp} notification that matches the filtering condition on its location and value. Tesla rules define complex events from simpler ones, which may emanate from actual sources, or be complex events defined by other rules, thus leading to a hierarchy of events. A rule has the following form:
\begin{lstlisting}[language=tesla]
	define CE(attr1 : Type1, ..., attrN : TypeN)
	from   Pattern
	where  attr1 := f1, ..., attrN := fN
\end{lstlisting}
Intuitively, a rule defines a complex event \lstinline[language=tesla]{CE} together with its signature (i.e. an ordered, typed list of attributes) that issues \lstinline[language=tesla]{CE} notifications whenever the \lstinline[language=tesla]{Pattern} is matched, assigning values to \lstinline[language=tesla]{CE} attributes from the functions defined in the \lstinline[language=tesla]{where} clause (that may depend on elements of the \lstinline[language=tesla]{Pattern}). Valid patterns include event \emph{occurrences} that filter attribute values (e.g., \lstinline[language=tesla]{from Temp.val > 20}), event \emph{compositions} that combine events together with boolean operators or time windows (e.g., \lstinline[language=tesla]{from Rain and Temp.val > 20 within 5min from Smoke}, indicating that a temperature reading above 20Â°C should occur within five minutes from a \lstinline[language=tesla]{Smoke} notification, while raining); event \emph{negation} (e.g., \lstinline[language=tesla]{from not Rain between Temp and Smoke}, indicating that it should not rain between an elevated temperature reading and a smoke notification). Tesla proposes more powerful patterns like aggregation and iterations, but we will not use them in our examples.
Note that the server is interactive so that clients can (un-)subscribe while the engine is running and rules may be added or deleted at runtime without affecting the overall infrastructure. 

From the perspective of \IOTDSL, TRex offers several benefits as a \CEP engine middleware: TRex is powerful enough to handle typical \IOT scenarios like the one described in Section \ref{sec:Motivation}, thanks to the expressive power of Tesla. It adopts a decentralised architecture that directly reflects our design choices, and supports distributed processing of events to reduce the cost of communication and to optimise resource usage. It is developed in C, so it is even suitable for \textit{small form factor} middlewares. Finally, on top of a C \textsc{API}, Java libraries have been developed on which we rely to generate devices' simulation code.
