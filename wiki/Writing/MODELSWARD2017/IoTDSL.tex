\section{IoTDSL}
\label{sec:IoTDSL}

\begin{figure*}%
%\includegraphics[width=\columnwidth]{filename}%
\caption{Alice's Smart Home equipped with various devices.}%
\label{fig:RE}%
\end{figure*}

Building a well-calibrated \DSL is known to be difficult and error-prone, and usually requires a large expertise on a domain and its many variations before a consensus on which concepts are important and how to effectively represent them. Fortunately, \MDE technology operated substantial breakthrough over the past decade, allowing language designers to easily define their \DSL structure and user interface. A \DSL is often required to exhibit a visual syntax, allegedly for simplifying its understanding and handling among end-users; however, in order to obtain a functional prototype faster, we chose to start with a textual syntax, which is easier to manipulate and evolve. Ultimately, we still want to propose a visual interface: the transition should be facilitated since \IOTDSL is developed from the start in GeMoC \cite{}, an \textsc{Mde} framework supporting both visual and textual representations as concrete syntaxes and maintaining a complete synchronisation between both versions.

Based on the concerns and the challenges indentified in the previous sections, we present now \IOTDSL, our \DSL for facilitating the high-level manipulation of \IOT systems. Although at it early stages of development, \IOTDSL showed its ability to appropriately capture the definition of small-scale \IOT systems. We first extract a simple scenario from our project at the University to demonstrate typical usage of \IOT systems deployed inside a house. We then simultaneously explain each part of \IOTDSL definition, and illustrate it on our example.

\subsection{Running Example}
\label{sec:IoTDSL-Example}


For illustrating our proposal, we consider a smart home equipped with several devices, just like Alice's situation in Section \ref{sec:Context-Challenges}, as illustrated in Figure \ref{fig:RE}. At the entrance, the door is equipped with a lock detector, allowing to know when the door is opened or closed; the hallway contains movement detectors: in that way, Alice wants that the lights in the hallway as well as the living room automatically switch on when she arrives home. Furthermore, the living room also contains a presence detector: Alice wants that the temperature would be automatically monitored when occupying the room, and maintained between 20째C and 22째C; otherwise, the temperature may not go below 16째C. For security reasons, Alice's kitchen contains a smoke detector and a temperature monitor. When she cooks, it happens that she burns something; but she wants to make sure to detect any departing fire: she considers it a critical situation when the temperature remains above 45째C consistently during five minutes while there is also smoke in the kitchen. 


Figure \ref{fig:RE} shows how the various devices are physically distributed inside an archetypal representation of a smart home, and how each device communicate with a centralised gateway. In our \DSL, the gateway centralises the data received from the devices deployed inside the home, and keeps the business logic running, i.e. receiving data from and acting through the devices. 

\subsection{Type Definition}
\label{sec:IoTDSL-Type}

This part defines \IOT devices' types, i.e. which capabilities, in terms of sensing the environment and actuating on it, are available to the user. In our scenario, type definitions either come from an advanced user who is able to properly reason about a particular device and extract the relevant information; or from a pre-existing devices database, be it an actual database the system is connected to, or a library made available to users. From a metamodel viewpoint, this part is similar to the notion of \textsf{Classifier} in \textsc{Mof}-like languages: a \textsf{Type} is either a \textsf{PrimitiveType} (integer and real numbers, string and booleans), or a user-defined \textsf{DeclaredType}. We distinguish between general \textsf{Gateway}s, which centralise information and processing, from \textsf{Node}s, which possess capabilities and are deployed in the environment. A \textsf{Capability} is basically a \textsc{Mof}-like operation with a signature, expressed through a list of (input/output typed) \textsf{Parameter}s that either captures data from the environment, or acts on it. A \textsf{Node} can mix both kinds of capabilities, allowing us to represent in a uniform fashion composite devices that expose complex behaviours.
	
For now, type definitions are defined as specific files that can be imported and combined easily within an \IOT specification. Ultimately, we will propose a graphical interface that would facilitate the browsing of library components and their seamless integration into \IOT systems.

Figure \ref{fig:RE-Typing} shows how the devices used in the Running Example are declared in \IOTDSL: each device is introduced by the keyword \textsf{device}, and has a name and capabilities that correspond to reporting events (\textsf{sensing}) or acting on the environment (\textsf{actuating}). A special device, introduced by the keyword \textsf{gateway}, centralises data from all devices connected to it (cf. Section \ref{sec:IoTDSL-NetworkConfiguration}). Note that this is the visible part of \IOTDSL: in the background, the events declared for each device need to be mapped to low-level events that the devices actually use. For that purpose, \IOTDSL contains a mapping language aimed at synchronising high- and low-level events that is not detailed here for space reasons.

\begin{figure}[t]%
%\includegraphics[width=\columnwidth]{filename}%
\caption{Typing declaration for the devices inside Alice's House.}%
\label{fig:RE-Typing}%
\end{figure}	
	
\subsection{Network Configuration}
\label{sec:IoTDSL-NetworkConfiguration}

This part defines how devices are connected: an actual device within a system is represented by a \textsf{NodeInstance} and is typed by a \textsf{Node} or a \textsf{Gateway}; instances communicate with other \IOT devices or gateways through predefined \textsf{CommunicationPath}s: such a path defines, among other information, the protocol(s) used for communication. We rely on existing platforms such as OpenRemote or SmartThing to handle the communication protocols intricate details, since those details are, from the user viewpoint, technical aspects rather than essential points. By knowing which protocols are used between each pair of devices, we can perform data conversion in the proper format required by the protocols automatically: most of those protocols are already implemented in General-Purpose Programming Languages (\textsc{Gpl}s), like Java or C, to name a few.
	
From a practical viewpoint, we can easily imagine that network configurations are automatically established if devices follow the recommendation of discovery protocols (cf. \cite{} for an overview): by centralising the connections on a gateway in charge of centralising the upcoming or leaving devices (e.g., phones that enter or leave a house, or devices that dis-/connect), it becomes possible to gather information on new devices and connect them appropriately to other devices in the network according to their capabilities, communication protocols, and so on.

Figure \ref{fig:RE-Network} shows the connection between devices, as illustrated in Figure \ref{fig:RE}: a specific device is considered as an instance of a type, as declared in Section \ref{sec:IoTDSL-Type}, which allows to distinguish different devices with the same set of capabilities through different references (reference names are just here for illustration purposes); the communication is purely declarative and only mentions the protocol type (after the \textsf{via} keyword).   

\begin{figure}[t]%
%\includegraphics[width=\columnwidth]{filename}%
\caption{Network Configuration for the devices present in Alice's House}%
\label{fig:RE-Network}%
\end{figure}	
	
\subsection{Business Rules}
\label{sec:IoTDSL-BusinessRules}

This last part of our \DSL is the heart of \IOT systems manipulation: it relies on an event-based framework consisting of a set of \textsf{Rule}s that implements various functionalities the end-user wants to achieve: rules' \textsf{trigger}s are cyclically evaluated against the surrounding environment: whenever a \textsf{trigger} \textsf{Expression} becomes true, it executes the appropriate \textsf{reaction} associated to the rule. A \textsf{trigger} is defined by an expression, whose precise definition is omitted here, since it simply follows classical expression languages from \textsc{Gpl}s for navigating nodes and evaluating boolean and arithmetic expressions (note that detecting the \emph{absence} of events is left for future work, since this is known to be difficult: as a consequence, the expression language does not integrate boolean negation). A \textsf{reaction} defines a sequential or parallel combination of capabilities, allowing to order an action by, or to require a data from some devices (or all devices of the same type, for example blinking all lights in a house).
	
Rules are usually centralised into a gateway, or nodes with high processing capabilities and power resources. 

