\chapter{Syntax}
\label{sec:Syntax}

TESLA Language \cite{Cugola-Margara:2010}

\section{Subscription}
\label{sec:Subscription}

Subscribe to an event (in fact, to event notifications of a
certain type) eventually filtered

\begin{lstlisting}[language=iotdsl]
Subscribe(Temp, Room = "Room1" AND Value > 20)
\end{lstlisting}

\section{Rule}
\label{sec:Rule}

\begin{itemize}
	\item Define a new Complex Event \textsf{CE} that possesses typed attributes
			$(att_n)_{n\in\mathbb{N}}$ from \textsf{Pattern}, with \textsf{CE}'s attributes binding defined in the where clause, while consuming events $(e_i)_i$.

\begin{lstlisting}[language=iotdsl]
define CE(att1: Type1, ..., attN: TypeN)
from Pattern
where att1= f\_1, ..., attN= f\_n
consuming e1,..,en
\end{lstlisting}

	\item To ensure that CE's definition is consistent with regular low-level (aka.
			simple) events, we assume that events are declared as follows:

\begin{lstlisting}[language=iotdsl]
E(
  att1 : Type1
  ...
  attN : TypeN
)
\end{lstlisting}

	\item The examples suggest that type declaration for CE's attributes is sometimes inferred. Is it reasonable to do that?
\end{itemize}







\section{Selecting a Single Event SE}
\label{sec:SelectingASingleEventSE}

This construction filters relevant event notifications according to their attributes' values.

\begin{lstlisting}[language=iotdsl]
define Overflow(Name)
from WaterLevel(level > 20) as WL
where Name = WL.name
\end{lstlisting}

\medskip
\noindent
\textbf{Questions:}
\begin{itemize}
	\item Which syntax is better for selection?
	\begin{itemize}
		\item from WaterLevel(level > 20)
		\item from WaterLevel.level > 20
		\item from WaterLevel[()] with level > 20
	\end{itemize}
	\item How about best practice: 
	\begin{itemize}
		\item defined event's attribute names start with a uppercase letter;
		\item used event's attribute names start with a lowercase letter.
	\end{itemize}
\end{itemize}

\section{Composing Events}
\label{sec:ComposingEvents}

For composing events, the language relies on both \emph{conjunction} (\textsf{and}) and \emph{sequence} between events, as well as \emph{windows} (\textsf{each-within-from}) defining the maximum timeframe between patterns.

\begin{lstlisting}[language=iotdsl]
define Fire(Val)
from   Smoke() and
       each Temp(val > 45) within 5min from Smoke
where  Val = Temp.val

define Fire(Val)
from   Smoke() and
       last Temp(val > 45) within 5min from Smoke
where  Val = Temp.val

define CE()
from   A() and 
       each B() within 10min from A

define CE()
from   A(va > 1) and 
       each B(vb > 2) within 2 min from A and 
		 each E() within 3 min from B

define D()
from   A() and 
       each  B() within 5min from A and
       last  C() within 3min from A and
       last  D() within 6min from B and
       first E() within 2min from D and
             E() within 8min from A

define CE()
from   A(va > 1) and 
       each B(vb > 2) within 2 min from A and 
       each C(vc < 3) within 4 min from A and 
       each D(vd = 5) within 4 min from B and 
       D within 5 min from C and 
       each E() within 3 min from B
\end{lstlisting}

\medskip
\noindent
\textbf{Questions:}
\begin{itemize}
	\item Same about selection's best syntax
	\item How to detect cycles/well-formed expressions?\\
			=> Partial Order Occurence Graph defined structurally from the rule
\end{itemize}

\section{Parameterisation}
\label{sec:Parameterisation}

This construction introduces constraints over the values of different event notifications.

\begin{lstlisting}[language=iotdsl]
define Fire(Val)
from   Smoke(area = \$x) and
       each Temp(val > 45 and area = \$x) within 5min from Smoke
where  Val = Temp.val
\end{lstlisting}


\section{Negation}
\label{sec:Negation}

This construction prescribes the absence of certain events.

\begin{lstlisting}[language=iotdsl]
define Fire(Val)
from   Smoke(area = \$x) and
       each Temp(val > 45 and area = \$x) within 5min from Smoke and
       not Rain(area = \$x) between Temp and Smoke
where  Val = Temp.val

define Fire(Val)
from   Smoke(area = \$x) and
       each Temp(val > 45 and area = \$x) within 5min from Smoke and
       not Rain(area = \$x) within 5min from Smoke
where  Val = Temp.val
\end{lstlisting}

\begin{itemize}
	\item Interval expressed either with within-from or with between-and; the
latter already assumes that the first argument precedes the second\\
=> How do we check that?
\end{itemize}

\section{Consumption}
\label{sec:Consumption}

This construction specifies the consumption policy for matched events.

\begin{lstlisting}[language=iotdsl]
define Fire(Val)
from   Smoke() and 
       each Temp(val > 45) within 5min from Smoke
where  Val = Temp.val
consuming Temp
\end{lstlisting}


\subsection{Aggregation}
\label{sec:Aggregation}

This construction introduces constraints involving some aggregated value.

\begin{lstlisting}[language=iotdsl]
define AvgTemp(Val)
from   Timer(M \% 5 == 0)
where  Val = Avg(Temp().val) within 5min from Timer

define HighVal(Name, Val)
from   Stock(name = \$y, val = \$x) as S and
       last Opening() within 1day from Stock and
       \$x > Avg(Stock(name = \$y).val) between Opening and Stock
where  Val = S.val, Name = S.name
\end{lstlisting}

\subsection{Iteration}
\label{sec:Iteration}

This construction allows to capture several iterations of the same event.

\begin{lstlisting}[language=iotdsl]
define RepA(Times, Val)
from   A()
where  Times = 1 and Val = A.val

define RepA(Times, Val)
from   A(\$x) and 
       last RepA(Val <= \$x) within 3min from A
where  Times = RepA.Times + 1 and Val = \$x
consuming RepA

define B(Times)
from   RepA()
where  Times = RepA.times
\end{lstlisting}

\medskip
\noindent
\textbf{Questions:}
\begin{itemize}
	\item How to propose syntactic sugar to improve iteration specification?
\end{itemize}

\section{Alternative Syntax \cite{Margara-Cugola-Tamburrelli:2014}}
\label{sec:AlternativeSyntax}

This construction introduces a window of 5 minutes to accept two events \textsf{Temp} and \textsf{Smoke} (\emph{conjunction}), such that the temp value exceeds 50\textdegree C within the same area as where \textsf{Smoke} is detected.

\begin{lstlisting}[language=iotdsl]
within 5min { Smoke(area=$a) and Temp(area=$a and value>50) }
\end{lstlisting}

This construction uses the same conjunction but shows a simple syntactic construction \textsf{->} to capture event \emph{sequence}, stating that both \textsf{Temp} and \textsf{Wind} should occur before \textsf{Smoke}.

\begin{lstlisting}[language=iotdsl]
within 5min { Smoke() and Temp(value>50) and Wind(speed>20) } where { Temp->Smoke, Wind->Smoke }
\end{lstlisting}

The following construction uses an \emph{aggregation} and a \emph{negation}.

\begin{lstlisting}[language=iotdsl]
within 5min { Smoke() and Avg(Temp.value)>50 and not Rain(mm>2) } where { Temp->Smoke }
\end{lstlisting}

